#+title: Git
#+author: Miguel Piña
#+date: [2017-02-19 dom 18:50]
#+setupfile: ~/proyectos/org-html-themes/setup/theme-bigblow.setup

* Sistemas de control de versiones

Un sistema de control de versiones, es un sistema de software que permite llevar
el registro y la gestión de los cambios que se dan sobre los elementos de algún
producto.

Una versión, revisión o edición de un producto, es el estado  en el que se
encuentra el mismo en un momento dado de su desarrollo o modificación.

El control de versiones se realiza principalmente dentro del desarrollo de
software para controlar las distintas versiones del código fuente dando lugar a
los sistemas de control de código fuente.

* ¿Por qué necesito uno?

Es necesario llevar un control de los distintos tipos de cambios que se realizan
sobre el código que implementamos.

Además, si estamos trabajando de forma colaborativa, también es necesario llevar
un registro de quien o quienes implementaron alguna características, el por qué
se implementó de cierto modo, etc.

Además permite llevar el código a un estado anterior sin perder la información
más reciente.

* ¿Qué SCV's existen?

Los sistemas de control de versiones más populares en este momento son:

- Subversión (Svn)
- git
- Mercurial

En este curso vamos a utilizar git como SCV.

* ¿Cómo obtener git?

La última versión de git se puede obtener desde la página:

https://git-scm.com/

Se recomienda que todos los integrantes del equipo tengan la misma versión
instalada.

* ¿Qué es git?

GIT es un software de control de versiones diseñado por Linus Torvalds, pensando
en la eficiencia y la confiabilidad del mantenimiento de versiones de
aplicaciones cuando estas tienen un gran número de archivos de código fuente.

Git surge como alternativa a BitKeeper, un control de versiones privativo que
usaba en ese entonces para el kernel. Es liberado bajo una licencia GNU GPLv2 y
se ha convertido en uno de los más usados alrededor del mundo.

* Usando git

** Inicializando git

Para usar git, hay que crear una carpeta donde vamos a llevar el control de
versiones de nuestro código, vamos a hacer lo siguiente:

#+begin_src sh
mkdir mi-proyecto  # Creamos una carpeta para el proyecto
cd mi-proyecto     # Nos movemos a esa carpeta
git init           # Inicializamos el repositorio
#+end_src

** Checando el estado del proyecto

La forma en que inicializamos nuestro proyecto con gil, es a través de la
instrucción /git init/. Una vez inicializado el proyecto, procedemos a revisar el
estado del repositorio con /git status/.

#+begin_src sh
git status
#+end_src

** Agregando archivos y comiteandolos.

He creado un archivo llamado README.org que va a contener la descripción del
proyecto. Por ejemplo, tendría algo como lo siguiente:

#+begin_src org
  ,#+title: Mi proyecto
  ,#+author: Miguel Piña
  ,#+date: [2017-02-19 dom 19:36]

  Es es un ejemplo de descripción para mi primer proyecto en git. Seguro contendrá
  el modo de uso y un proyecto en maven.

  ,* ¿Cómo compilar el proyecto?
  ,** Como configurar la base de datos para que compile el proyecto
  ,** ¿Qué dependencias son necesarias?
  ,* Estilo de codificación
  ,* Gotchas
#+end_src

Para agregar este primer archivo a nuestro proyecto, vamos a realizar lo
siguiente:

#+begin_src sh
git add README.org
git status
#+end_src

La forma de hacer el commit de una modificación y que quede registrada es con la
instrucción /git commit/. Existe una variante en la que se puede agregar un
mensaje directamente sin tener que abrir el editor de texto: /git commit -m
"Agregando el README"/, pero esta no la vamos utilizar en este momento.

#+begin_src sh
git commit
#+end_src

Los pasos anteriores se puede repetir tantas veces como sea necesario. Existen
herramientas que facilitan estos pasos en Netbeans como en Emacs. La primera
viene integrada dentro de Netbeans y la segunda como un plugin llamado /magit/.

** Viendo el historial de cambios

Para ver la lista de cambios que tiene un proyecto dado, es posible usar la
siguiente instrucción:

#+begin_src sh
git log
#+end_src

También se puede agrega una variante para que sea posible verla en forma de
grafo dentro de la terminal:

#+begin_src sh
git log --graph --decorate --pretty=oneline --abbrev-commit
#+end_src

La sentencia anterior se puede agregar a un alias dentro de un archivo de
configuración =~/.gitconfig=, a algo como:

#+begin_src sh
[alias]
    tree = log --graph --decorate --pretty=oneline --abbrev-commit
#+end_src

Y se puede invocar como:

#+begin_src sh
git tree
#+end_src

** Agregando repositorios remotos

Hay que crear un repositorio remoto (en github) y agregamos la siguiente
instrucción:

#+begin_src sh
git remote add origin https://github.com/miguelpinia/something.git
#+end_src

Hay que remplazar la url por la del repositorio. Una vez agregado el repositorio
remoto, hay que empujar todos los cambios que hemos hecho en nuestro repositorio
local:

#+begin_src sh
git push -u origin master
#+end_src

** Obteniendo cambios desde el repositorio remoto

Supongamos que alguien hizo cambios en el repositorio y los empujó al
repositorio, para obtener esos cambios, ejecutamos la instrucción:

#+begin_src sh
git pull
#+end_src

Para ver cuales fueron los cambios que se hicieron entre el último commit que
teníamos y el que obtuvimos ejecutamos:

#+begin_src sh
git diff HEAD
#+end_src

** Creando ramas

Para agregar cambios sin modificar el contenido de la rama principal (rama
master), vamos a crear una nueva rama donde podamos trabajar. Para hacer esto,
realizamos lo siguiente:

#+begin_src sh
git checkout -b mi_nueva_rama
#+end_src

A partir de aquí podemos realizar nuevos cambios. Para regresar o moverse entre
ramas, usando el comando checkout sin banderas.

#+begin_src sh
git checkout master
#+end_src

** Mezclando ramas

Después de realizar una serie de cambios, es necesario que se mezclen con la
rama principal. Una forma limpia de hacerlo, es haciendo un rebase de la rama
con la que estamos trabajando respecto a la que vamos a mezclar.

La acción de rebase, se refiere a desplazar todos los cambios que existan en la
rama a mezclar y que no se han integrado con la rama que estamos trabajando.

#+begin_src sh
git checkout mi_nueva_rama
git rebase master
git checkout master
git merge --no-ff mi_nueva_rama
git push
#+end_src

** Eliminando ramas

La forma sencilla de eliminar ramas dentro de git es la siguiente:

#+begin_src sh
git branch -d mi_nueva_rama
#+end_src
